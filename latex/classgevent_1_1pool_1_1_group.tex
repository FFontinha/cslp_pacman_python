\hypertarget{classgevent_1_1pool_1_1_group}{}\section{gevent.\+pool.\+Group Class Reference}
\label{classgevent_1_1pool_1_1_group}\index{gevent.\+pool.\+Group@{gevent.\+pool.\+Group}}


Inherits \hyperlink{classgevent_1_1pool_1_1_group_mapping_mixin}{gevent.\+pool.\+Group\+Mapping\+Mixin}.



Inherited by \hyperlink{classgevent_1_1pool_1_1_pool}{gevent.\+pool.\+Pool}.

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classgevent_1_1pool_1_1_group_a19d8f7197b5759ba30170538e8da8d52}\label{classgevent_1_1pool_1_1_group_a19d8f7197b5759ba30170538e8da8d52}} 
def {\bfseries \+\_\+\+\_\+init\+\_\+\+\_\+} (self, args)
\item 
\mbox{\Hypertarget{classgevent_1_1pool_1_1_group_adb632ad759844cecd1b55df1390ffa21}\label{classgevent_1_1pool_1_1_group_adb632ad759844cecd1b55df1390ffa21}} 
def {\bfseries \+\_\+\+\_\+repr\+\_\+\+\_\+} (self)
\item 
def \hyperlink{classgevent_1_1pool_1_1_group_afae785c70abd12596435a98fa2440d55}{\+\_\+\+\_\+len\+\_\+\+\_\+} (self)
\item 
def \hyperlink{classgevent_1_1pool_1_1_group_ae6fb0617f6960e9d013e20d4a41ee4cf}{\+\_\+\+\_\+contains\+\_\+\+\_\+} (self, item)
\item 
def \hyperlink{classgevent_1_1pool_1_1_group_a813354827619c66daf0d1ab2acef81e3}{\+\_\+\+\_\+iter\+\_\+\+\_\+} (self)
\item 
def \hyperlink{classgevent_1_1pool_1_1_group_a2e4dea7c78ceebc47140efd42b420b73}{add} (self, greenlet)
\item 
def \hyperlink{classgevent_1_1pool_1_1_group_a72d55b247f93a2ce245f579e39e489a0}{discard} (self, greenlet)
\item 
def \hyperlink{classgevent_1_1pool_1_1_group_a50496ebf90113d8b8388e84b36be820d}{start} (self, greenlet)
\item 
def \hyperlink{classgevent_1_1pool_1_1_group_a17b15e843e0b151a3906c2f2c2167f55}{spawn} (self, args, kwargs)
\item 
def \hyperlink{classgevent_1_1pool_1_1_group_ad368620ebda7dee3d34b0d62ffbc9dfd}{join} (self, timeout=None, raise\+\_\+error=False)
\item 
def \hyperlink{classgevent_1_1pool_1_1_group_ada2edb0aaef544992fa1c967e1d2094f}{kill} (self, exception=Greenlet\+Exit, block=True, timeout=None)
\item 
def \hyperlink{classgevent_1_1pool_1_1_group_a8aaf4090368477a74d27d866cd1e0a9b}{killone} (self, greenlet, exception=Greenlet\+Exit, block=True, timeout=None)
\item 
def \hyperlink{classgevent_1_1pool_1_1_group_a60ab870aee8f8e804b272e4b36d8a4fc}{full} (self)
\item 
def \hyperlink{classgevent_1_1pool_1_1_group_af9ad7f7c08e17a7b40aaa7dab049466a}{wait\+\_\+available} (self, timeout=None)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classgevent_1_1pool_1_1_group_a5a19a7e540744cfa5d99b6346d08f63e}\label{classgevent_1_1pool_1_1_group_a5a19a7e540744cfa5d99b6346d08f63e}} 
{\bfseries greenlets}
\item 
\mbox{\Hypertarget{classgevent_1_1pool_1_1_group_a3899c6e8ef072ad586a92da10983429f}\label{classgevent_1_1pool_1_1_group_a3899c6e8ef072ad586a92da10983429f}} 
{\bfseries dying}
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classgevent_1_1pool_1_1_group_a194194eca73a1e24f9d8fbc7020d97af}\label{classgevent_1_1pool_1_1_group_a194194eca73a1e24f9d8fbc7020d97af}} 
{\bfseries greenlet\+\_\+class} = \hyperlink{classgevent_1_1greenlet_1_1_greenlet}{Greenlet}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Maintain a group of greenlets that are still running, without
limiting their number.

Links to each item and removes it upon notification.

Groups can be iterated to discover what greenlets they are tracking,
they can be tested to see if they contain a greenlet, and they know the
number (len) of greenlets they are tracking. If they are not tracking any
greenlets, they are False in a boolean context.
\end{DoxyVerb}
 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classgevent_1_1pool_1_1_group_ae6fb0617f6960e9d013e20d4a41ee4cf}\label{classgevent_1_1pool_1_1_group_ae6fb0617f6960e9d013e20d4a41ee4cf}} 
\index{gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}!\+\_\+\+\_\+contains\+\_\+\+\_\+@{\+\_\+\+\_\+contains\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+contains\+\_\+\+\_\+@{\+\_\+\+\_\+contains\+\_\+\+\_\+}!gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+contains\+\_\+\+\_\+()}{\_\_contains\_\_()}}
{\footnotesize\ttfamily def gevent.\+pool.\+Group.\+\_\+\+\_\+contains\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{item }\end{DoxyParamCaption})}

\begin{DoxyVerb}Answer if we are tracking the given greenlet.
\end{DoxyVerb}
 \mbox{\Hypertarget{classgevent_1_1pool_1_1_group_a813354827619c66daf0d1ab2acef81e3}\label{classgevent_1_1pool_1_1_group_a813354827619c66daf0d1ab2acef81e3}} 
\index{gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}!\+\_\+\+\_\+iter\+\_\+\+\_\+@{\+\_\+\+\_\+iter\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+iter\+\_\+\+\_\+@{\+\_\+\+\_\+iter\+\_\+\+\_\+}!gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+iter\+\_\+\+\_\+()}{\_\_iter\_\_()}}
{\footnotesize\ttfamily def gevent.\+pool.\+Group.\+\_\+\+\_\+iter\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Iterate across all the greenlets we are tracking, in no particular order.
\end{DoxyVerb}
 \mbox{\Hypertarget{classgevent_1_1pool_1_1_group_afae785c70abd12596435a98fa2440d55}\label{classgevent_1_1pool_1_1_group_afae785c70abd12596435a98fa2440d55}} 
\index{gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}!\+\_\+\+\_\+len\+\_\+\+\_\+@{\+\_\+\+\_\+len\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+len\+\_\+\+\_\+@{\+\_\+\+\_\+len\+\_\+\+\_\+}!gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+len\+\_\+\+\_\+()}{\_\_len\_\_()}}
{\footnotesize\ttfamily def gevent.\+pool.\+Group.\+\_\+\+\_\+len\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Answer how many greenlets we are tracking. Note that if we are empty,
we are False in a boolean context.
\end{DoxyVerb}
 \mbox{\Hypertarget{classgevent_1_1pool_1_1_group_a2e4dea7c78ceebc47140efd42b420b73}\label{classgevent_1_1pool_1_1_group_a2e4dea7c78ceebc47140efd42b420b73}} 
\index{gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}!add@{add}}
\index{add@{add}!gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}}
\subsubsection{\texorpdfstring{add()}{add()}}
{\footnotesize\ttfamily def gevent.\+pool.\+Group.\+add (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{greenlet }\end{DoxyParamCaption})}

\begin{DoxyVerb}Begin tracking the *greenlet*.

If this group is :meth:`full`, then this method may block
until it is possible to track the greenlet.

Typically the *greenlet* should **not** be started when
it is added because if this object blocks in this method,
then the *greenlet* may run to completion before it is tracked.
\end{DoxyVerb}
 \mbox{\Hypertarget{classgevent_1_1pool_1_1_group_a72d55b247f93a2ce245f579e39e489a0}\label{classgevent_1_1pool_1_1_group_a72d55b247f93a2ce245f579e39e489a0}} 
\index{gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}!discard@{discard}}
\index{discard@{discard}!gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}}
\subsubsection{\texorpdfstring{discard()}{discard()}}
{\footnotesize\ttfamily def gevent.\+pool.\+Group.\+discard (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{greenlet }\end{DoxyParamCaption})}

\begin{DoxyVerb}Stop tracking the greenlet.
\end{DoxyVerb}
 \mbox{\Hypertarget{classgevent_1_1pool_1_1_group_a60ab870aee8f8e804b272e4b36d8a4fc}\label{classgevent_1_1pool_1_1_group_a60ab870aee8f8e804b272e4b36d8a4fc}} 
\index{gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}!full@{full}}
\index{full@{full}!gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}}
\subsubsection{\texorpdfstring{full()}{full()}}
{\footnotesize\ttfamily def gevent.\+pool.\+Group.\+full (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a value indicating whether this group can track more greenlets.

In this implementation, because there are no limits on the number of
tracked greenlets, this will always return a ``False`` value.
\end{DoxyVerb}
 \mbox{\Hypertarget{classgevent_1_1pool_1_1_group_ad368620ebda7dee3d34b0d62ffbc9dfd}\label{classgevent_1_1pool_1_1_group_ad368620ebda7dee3d34b0d62ffbc9dfd}} 
\index{gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}!join@{join}}
\index{join@{join}!gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}}
\subsubsection{\texorpdfstring{join()}{join()}}
{\footnotesize\ttfamily def gevent.\+pool.\+Group.\+join (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{timeout = {\ttfamily None},  }\item[{}]{raise\+\_\+error = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Wait for this group to become empty *at least once*.

If there are no greenlets in the group, returns immediately.

.. note:: By the time the waiting code (the caller of this
   method) regains control, a greenlet may have been added to
   this group, and so this object may no longer be empty. (That
   is, ``group.join(); assert len(group) == 0`` is not
   guaranteed to hold.) This method only guarantees that the group
   reached a ``len`` of 0 at some point.

:keyword bool raise_error: If True (*not* the default), if any
    greenlet that finished while the join was in progress raised
    an exception, that exception will be raised to the caller of
    this method. If multiple greenlets raised exceptions, which
    one gets re-raised is not determined. Only greenlets currently
    in the group when this method is called are guaranteed to
    be checked for exceptions.

:return bool: A value indicating whether this group became empty.
   If the timeout is specified and the group did not become empty
   during that timeout, then this will be a false value. Otherwise
   it will be a true value.

.. versionchanged:: 1.2a1
   Add the return value.
\end{DoxyVerb}
 \mbox{\Hypertarget{classgevent_1_1pool_1_1_group_ada2edb0aaef544992fa1c967e1d2094f}\label{classgevent_1_1pool_1_1_group_ada2edb0aaef544992fa1c967e1d2094f}} 
\index{gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}!kill@{kill}}
\index{kill@{kill}!gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}}
\subsubsection{\texorpdfstring{kill()}{kill()}}
{\footnotesize\ttfamily def gevent.\+pool.\+Group.\+kill (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{exception = {\ttfamily GreenletExit},  }\item[{}]{block = {\ttfamily True},  }\item[{}]{timeout = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Kill all greenlets being tracked by this group.
\end{DoxyVerb}
 \mbox{\Hypertarget{classgevent_1_1pool_1_1_group_a8aaf4090368477a74d27d866cd1e0a9b}\label{classgevent_1_1pool_1_1_group_a8aaf4090368477a74d27d866cd1e0a9b}} 
\index{gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}!killone@{killone}}
\index{killone@{killone}!gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}}
\subsubsection{\texorpdfstring{killone()}{killone()}}
{\footnotesize\ttfamily def gevent.\+pool.\+Group.\+killone (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{greenlet,  }\item[{}]{exception = {\ttfamily GreenletExit},  }\item[{}]{block = {\ttfamily True},  }\item[{}]{timeout = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}If the given *greenlet* is running and being tracked by this group,
kill it.
\end{DoxyVerb}
 \mbox{\Hypertarget{classgevent_1_1pool_1_1_group_a17b15e843e0b151a3906c2f2c2167f55}\label{classgevent_1_1pool_1_1_group_a17b15e843e0b151a3906c2f2c2167f55}} 
\index{gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}!spawn@{spawn}}
\index{spawn@{spawn}!gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}}
\subsubsection{\texorpdfstring{spawn()}{spawn()}}
{\footnotesize\ttfamily def gevent.\+pool.\+Group.\+spawn (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{args,  }\item[{}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Begin a new greenlet with the given arguments (which are passed
to the greenlet constructor) and add it to the collection of greenlets
this group is monitoring.

:return: The newly started greenlet.
\end{DoxyVerb}
 \mbox{\Hypertarget{classgevent_1_1pool_1_1_group_a50496ebf90113d8b8388e84b36be820d}\label{classgevent_1_1pool_1_1_group_a50496ebf90113d8b8388e84b36be820d}} 
\index{gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}!start@{start}}
\index{start@{start}!gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}}
\subsubsection{\texorpdfstring{start()}{start()}}
{\footnotesize\ttfamily def gevent.\+pool.\+Group.\+start (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{greenlet }\end{DoxyParamCaption})}

\begin{DoxyVerb}Add the **unstarted** *greenlet* to the collection of greenlets
this group is monitoring, and then start it.
\end{DoxyVerb}
 \mbox{\Hypertarget{classgevent_1_1pool_1_1_group_af9ad7f7c08e17a7b40aaa7dab049466a}\label{classgevent_1_1pool_1_1_group_af9ad7f7c08e17a7b40aaa7dab049466a}} 
\index{gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}!wait\+\_\+available@{wait\+\_\+available}}
\index{wait\+\_\+available@{wait\+\_\+available}!gevent\+::pool\+::\+Group@{gevent\+::pool\+::\+Group}}
\subsubsection{\texorpdfstring{wait\+\_\+available()}{wait\_available()}}
{\footnotesize\ttfamily def gevent.\+pool.\+Group.\+wait\+\_\+available (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{timeout = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Block until it is possible to :meth:`spawn` a new greenlet.

In this implementation, because there are no limits on the number
of tracked greenlets, this will always return immediately.
\end{DoxyVerb}
 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
venv/lib/python3.\+6/site-\/packages/gevent/pool.\+py\end{DoxyCompactItemize}
