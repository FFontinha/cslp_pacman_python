\hypertarget{namespacepygame_1_1examples_1_1vgrade}{}\section{pygame.\+examples.\+vgrade Namespace Reference}
\label{namespacepygame_1_1examples_1_1vgrade}\index{pygame.\+examples.\+vgrade@{pygame.\+examples.\+vgrade}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacepygame_1_1examples_1_1vgrade_aeade4e995f4ce754e380fbe3688d41f5}\label{namespacepygame_1_1examples_1_1vgrade_aeade4e995f4ce754e380fbe3688d41f5}} 
def {\bfseries stopwatch} (message=None)
\item 
\mbox{\Hypertarget{namespacepygame_1_1examples_1_1vgrade_a3ab68823cb6eca6b953c16ad3b43a104}\label{namespacepygame_1_1examples_1_1vgrade_a3ab68823cb6eca6b953c16ad3b43a104}} 
def {\bfseries Vert\+Gradient\+Column} (surf, topcolor, bottomcolor)
\item 
\mbox{\Hypertarget{namespacepygame_1_1examples_1_1vgrade_a432fa8b74592b82a272af35971b267fc}\label{namespacepygame_1_1examples_1_1vgrade_a432fa8b74592b82a272af35971b267fc}} 
def {\bfseries Display\+Gradient} (surf)
\item 
\mbox{\Hypertarget{namespacepygame_1_1examples_1_1vgrade_ae80020fdbdd5b3293c48c7585a7eed0a}\label{namespacepygame_1_1examples_1_1vgrade_ae80020fdbdd5b3293c48c7585a7eed0a}} 
def {\bfseries main} ()
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacepygame_1_1examples_1_1vgrade_a672f075a3c5819807e1ab7113824aa78}\label{namespacepygame_1_1examples_1_1vgrade_a672f075a3c5819807e1ab7113824aa78}} 
int {\bfseries timer} = 0
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}This example demonstrates creating an image with numpy
python, and displaying that through SDL. You can look at the
method of importing numpy and pygame.surfarray. This method
will fail 'gracefully' if it is not available.
I've tried mixing in a lot of comments where the code might
not be self explanatory, nonetheless it may still seem a bit
strange. Learning to use numpy for images like this takes a
bit of learning, but the payoff is extremely fast image
manipulation in python.

For Pygame 1.9.2 and up, this example also showcases a new feature
of surfarray.blit_surface: array broadcasting. If a source array
has either a width or height of 1, the array is repeatedly blitted
to the surface along that dimension to fill the surface. In fact,
a (1, 1) or (1, 1, 3) array results in a simple surface color fill.

Just so you know how this breaks down. For each sampling of
time, 30% goes to each creating the gradient and blitting the
array. The final 40% goes to flipping/updating the display surface

If using an SDL version at least 1.1.8 the window will have
no border decorations.

The code also demonstrates use of the timer events.\end{DoxyVerb}
 