\hypertarget{namespace__pytest_1_1compat}{}\section{\+\_\+pytest.\+compat Namespace Reference}
\label{namespace__pytest_1_1compat}\index{\+\_\+pytest.\+compat@{\+\_\+pytest.\+compat}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{class__pytest_1_1compat_1_1___pytest_wrapper}{\+\_\+\+Pytest\+Wrapper}
\item 
class \hyperlink{class__pytest_1_1compat_1_1_capture_i_o}{Capture\+IO}
\item 
class \hyperlink{class__pytest_1_1compat_1_1_funcargnames_compat_attr}{Funcargnames\+Compat\+Attr}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_a7af94b721264d3447618916058649812}\label{namespace__pytest_1_1compat_a7af94b721264d3447618916058649812}} 
def {\bfseries spec\+\_\+from\+\_\+file\+\_\+location} (\+\_\+, \+\_\+\+\_\+)
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_a11a1811ad55c7e60df0d196d05dca3cd}\label{namespace__pytest_1_1compat_a11a1811ad55c7e60df0d196d05dca3cd}} 
def {\bfseries is\+\_\+generator} (func)
\item 
def \hyperlink{namespace__pytest_1_1compat_ad5b3e6b075044794e72742004fd980f6}{iscoroutinefunction} (func)
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_abad49b167f5c0c6a3748f8e792af9f25}\label{namespace__pytest_1_1compat_abad49b167f5c0c6a3748f8e792af9f25}} 
def {\bfseries getlocation} (function, curdir)
\item 
def \hyperlink{namespace__pytest_1_1compat_af488d4507f9eca6c852d942058186efe}{num\+\_\+mock\+\_\+patch\+\_\+args} (function)
\item 
def \hyperlink{namespace__pytest_1_1compat_adba26e79f738dbde4738a8bf825ddc4e}{getfuncargnames} (function, is\+\_\+method=False, cls=None)
\item 
def \hyperlink{namespace__pytest_1_1compat_a3da3606628ba324edad1892c335aaa22}{dummy\+\_\+context\+\_\+manager} ()
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_a834e7b5fb64394e90061c33595535fcf}\label{namespace__pytest_1_1compat_a834e7b5fb64394e90061c33595535fcf}} 
def {\bfseries get\+\_\+default\+\_\+arg\+\_\+names} (function)
\item 
def \hyperlink{namespace__pytest_1_1compat_ae219e73cc18f92f906c0338ee2e095c1}{ascii\+\_\+escaped} (val)
\item 
def \hyperlink{namespace__pytest_1_1compat_a72cd14070d89cdcd90692007d8b6d1b0}{get\+\_\+real\+\_\+func} (obj)
\item 
def \hyperlink{namespace__pytest_1_1compat_a7cb5efdc829d81e210a6bad6a7ba0a9d}{get\+\_\+real\+\_\+method} (obj, holder)
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_a5a6228d7c718a2dff96d71d077400529}\label{namespace__pytest_1_1compat_a5a6228d7c718a2dff96d71d077400529}} 
def {\bfseries getfslineno} (obj)
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_a2583499614f5ac19cad0fb94adc1a1fd}\label{namespace__pytest_1_1compat_a2583499614f5ac19cad0fb94adc1a1fd}} 
def {\bfseries getimfunc} (func)
\item 
def \hyperlink{namespace__pytest_1_1compat_a7e7abdf5a8608ba2707053825e7818e8}{safe\+\_\+getattr} (object, name, default)
\item 
def \hyperlink{namespace__pytest_1_1compat_ada77abd26b1ef5408c324cba3d9614d3}{safe\+\_\+str} (v)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_a3666ad003430c603f42226cb52853a53}\label{namespace__pytest_1_1compat_a3666ad003430c603f42226cb52853a53}} 
{\bfseries enum} = None
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_aa6a8e9e49ed943c81f600c181c15ee78}\label{namespace__pytest_1_1compat_aa6a8e9e49ed943c81f600c181c15ee78}} 
{\bfseries None\+Type} = type(None)
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_a06ed38e60dc8a3cc670547e61a8edf22}\label{namespace__pytest_1_1compat_a06ed38e60dc8a3cc670547e61a8edf22}} 
{\bfseries N\+O\+T\+S\+ET} = object()
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_ad98312f90019865092fd20f5c2603fed}\label{namespace__pytest_1_1compat_ad98312f90019865092fd20f5c2603fed}} 
tuple {\bfseries P\+Y35} = (3, 5)
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_a77644981ed99a94975a94edb8c8874a1}\label{namespace__pytest_1_1compat_a77644981ed99a94975a94edb8c8874a1}} 
tuple {\bfseries P\+Y36} = (3, 6)
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_ae6e6703cf2f325ac4a31a4c05d0da1c3}\label{namespace__pytest_1_1compat_ae6e6703cf2f325ac4a31a4c05d0da1c3}} 
string {\bfseries M\+O\+D\+U\+L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+N\+D\+\_\+\+E\+R\+R\+OR} = \char`\"{}Module\+Not\+Found\+Error\char`\"{} if P\+Y36 else \char`\"{}Import\+Error\char`\"{}
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_ade3b11e38139a477e647c2932fa3fcf4}\label{namespace__pytest_1_1compat_ade3b11e38139a477e647c2932fa3fcf4}} 
{\bfseries isfunction} = inspect.\+isfunction
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_a2915123797e8004cb9f5d4f36d87ddea}\label{namespace__pytest_1_1compat_a2915123797e8004cb9f5d4f36d87ddea}} 
{\bfseries isclass} = inspect.\+isclass
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_a46dc3d6c1f88883dbf98ab74f5b879db}\label{namespace__pytest_1_1compat_a46dc3d6c1f88883dbf98ab74f5b879db}} 
{\bfseries exc\+\_\+clear} = getattr(sys, \char`\"{}exc\+\_\+clear\char`\"{}, lambda\+: None)
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_a91ac2d7336c3fc4e1b5017a2576660b3}\label{namespace__pytest_1_1compat_a91ac2d7336c3fc4e1b5017a2576660b3}} 
{\bfseries R\+E\+G\+E\+X\+\_\+\+T\+Y\+PE} = type(re.\+compile(\char`\"{}\char`\"{}))
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_a1412c317d7a5bc04aca5d14273ac5c67}\label{namespace__pytest_1_1compat_a1412c317d7a5bc04aca5d14273ac5c67}} 
{\bfseries S\+T\+R\+I\+N\+G\+\_\+\+T\+Y\+P\+ES} = bytes, str
\item 
\mbox{\Hypertarget{namespace__pytest_1_1compat_afd49290ab734e2ad2d6e1b323c5e412c}\label{namespace__pytest_1_1compat_afd49290ab734e2ad2d6e1b323c5e412c}} 
{\bfseries U\+N\+I\+C\+O\+D\+E\+\_\+\+T\+Y\+P\+ES} = six.\+text\+\_\+type
\item 
tuple {\bfseries C\+O\+L\+L\+E\+C\+T\+\_\+\+F\+A\+K\+E\+M\+O\+D\+U\+L\+E\+\_\+\+A\+T\+T\+R\+I\+B\+U\+T\+ES}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}python version compatibility code
\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespace__pytest_1_1compat_ae219e73cc18f92f906c0338ee2e095c1}\label{namespace__pytest_1_1compat_ae219e73cc18f92f906c0338ee2e095c1}} 
\index{\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}!ascii\+\_\+escaped@{ascii\+\_\+escaped}}
\index{ascii\+\_\+escaped@{ascii\+\_\+escaped}!\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}}
\subsubsection{\texorpdfstring{ascii\+\_\+escaped()}{ascii\_escaped()}}
{\footnotesize\ttfamily def \+\_\+pytest.\+compat.\+ascii\+\_\+escaped (\begin{DoxyParamCaption}\item[{}]{val }\end{DoxyParamCaption})}

\begin{DoxyVerb}If val is pure ascii, returns it as a str().  Otherwise, escapes
bytes objects into a sequence of escaped bytes:

b'\xc3\xb4\xc5\xd6' -> u'\\xc3\\xb4\\xc5\\xd6'

and escapes unicode objects into a sequence of escaped unicode
ids, e.g.:

'4\\nV\\U00043efa\\x0eMXWB\\x1e\\u3028\\u15fd\\xcd\\U0007d944'

note:
   the obvious "v.decode('unicode-escape')" will return
   valid utf-8 unicode if it finds them in bytes, but we
   want to return escaped bytes for any byte, even if they match
   a utf-8 string.\end{DoxyVerb}


\begin{DoxyVerb}In py2 bytes and str are the same type, so return if it's a bytes
object, return it unchanged if it is a full ascii string,
otherwise escape it into its binary form.

If it's a unicode string, change the unicode characters into
unicode escapes.\end{DoxyVerb}
 \mbox{\Hypertarget{namespace__pytest_1_1compat_a3da3606628ba324edad1892c335aaa22}\label{namespace__pytest_1_1compat_a3da3606628ba324edad1892c335aaa22}} 
\index{\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}!dummy\+\_\+context\+\_\+manager@{dummy\+\_\+context\+\_\+manager}}
\index{dummy\+\_\+context\+\_\+manager@{dummy\+\_\+context\+\_\+manager}!\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}}
\subsubsection{\texorpdfstring{dummy\+\_\+context\+\_\+manager()}{dummy\_context\_manager()}}
{\footnotesize\ttfamily def \+\_\+pytest.\+compat.\+dummy\+\_\+context\+\_\+manager (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyVerb}Context manager that does nothing, useful in situations where you might need an actual context manager or not
depending on some condition. Using this allow to keep the same code\end{DoxyVerb}
 \mbox{\Hypertarget{namespace__pytest_1_1compat_a72cd14070d89cdcd90692007d8b6d1b0}\label{namespace__pytest_1_1compat_a72cd14070d89cdcd90692007d8b6d1b0}} 
\index{\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}!get\+\_\+real\+\_\+func@{get\+\_\+real\+\_\+func}}
\index{get\+\_\+real\+\_\+func@{get\+\_\+real\+\_\+func}!\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}}
\subsubsection{\texorpdfstring{get\+\_\+real\+\_\+func()}{get\_real\_func()}}
{\footnotesize\ttfamily def \+\_\+pytest.\+compat.\+get\+\_\+real\+\_\+func (\begin{DoxyParamCaption}\item[{}]{obj }\end{DoxyParamCaption})}

\begin{DoxyVerb}gets the real function object of the (possibly) wrapped object by
functools.wraps or functools.partial.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespace__pytest_1_1compat_a7cb5efdc829d81e210a6bad6a7ba0a9d}\label{namespace__pytest_1_1compat_a7cb5efdc829d81e210a6bad6a7ba0a9d}} 
\index{\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}!get\+\_\+real\+\_\+method@{get\+\_\+real\+\_\+method}}
\index{get\+\_\+real\+\_\+method@{get\+\_\+real\+\_\+method}!\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}}
\subsubsection{\texorpdfstring{get\+\_\+real\+\_\+method()}{get\_real\_method()}}
{\footnotesize\ttfamily def \+\_\+pytest.\+compat.\+get\+\_\+real\+\_\+method (\begin{DoxyParamCaption}\item[{}]{obj,  }\item[{}]{holder }\end{DoxyParamCaption})}

\begin{DoxyVerb}Attempts to obtain the real function object that might be wrapping ``obj``, while at the same time
returning a bound method to ``holder`` if the original object was a bound method.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespace__pytest_1_1compat_adba26e79f738dbde4738a8bf825ddc4e}\label{namespace__pytest_1_1compat_adba26e79f738dbde4738a8bf825ddc4e}} 
\index{\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}!getfuncargnames@{getfuncargnames}}
\index{getfuncargnames@{getfuncargnames}!\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}}
\subsubsection{\texorpdfstring{getfuncargnames()}{getfuncargnames()}}
{\footnotesize\ttfamily def \+\_\+pytest.\+compat.\+getfuncargnames (\begin{DoxyParamCaption}\item[{}]{function,  }\item[{}]{is\+\_\+method = {\ttfamily False},  }\item[{}]{cls = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the names of a function's mandatory arguments.

This should return the names of all function arguments that:
    * Aren't bound to an instance or type as in instance or class methods.
    * Don't have default values.
    * Aren't bound with functools.partial.
    * Aren't replaced with mocks.

The is_method and cls arguments indicate that the function should
be treated as a bound method even though it's not unless, only in
the case of cls, the function is a static method.

@RonnyPfannschmidt: This function should be refactored when we
revisit fixtures. The fixture mechanism should ask the node for
the fixture names, and not try to obtain directly from the
function object well after collection has occurred.\end{DoxyVerb}
 \mbox{\Hypertarget{namespace__pytest_1_1compat_ad5b3e6b075044794e72742004fd980f6}\label{namespace__pytest_1_1compat_ad5b3e6b075044794e72742004fd980f6}} 
\index{\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}!iscoroutinefunction@{iscoroutinefunction}}
\index{iscoroutinefunction@{iscoroutinefunction}!\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}}
\subsubsection{\texorpdfstring{iscoroutinefunction()}{iscoroutinefunction()}}
{\footnotesize\ttfamily def \+\_\+pytest.\+compat.\+iscoroutinefunction (\begin{DoxyParamCaption}\item[{}]{func }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return True if func is a decorated coroutine function.

Note: copied and modified from Python 3.5's builtin couroutines.py to avoid import asyncio directly,
which in turns also initializes the "logging" module as side-effect (see issue #8).
\end{DoxyVerb}
 \mbox{\Hypertarget{namespace__pytest_1_1compat_af488d4507f9eca6c852d942058186efe}\label{namespace__pytest_1_1compat_af488d4507f9eca6c852d942058186efe}} 
\index{\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}!num\+\_\+mock\+\_\+patch\+\_\+args@{num\+\_\+mock\+\_\+patch\+\_\+args}}
\index{num\+\_\+mock\+\_\+patch\+\_\+args@{num\+\_\+mock\+\_\+patch\+\_\+args}!\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}}
\subsubsection{\texorpdfstring{num\+\_\+mock\+\_\+patch\+\_\+args()}{num\_mock\_patch\_args()}}
{\footnotesize\ttfamily def \+\_\+pytest.\+compat.\+num\+\_\+mock\+\_\+patch\+\_\+args (\begin{DoxyParamCaption}\item[{}]{function }\end{DoxyParamCaption})}

\begin{DoxyVerb}return number of arguments used up by mock arguments (if any) \end{DoxyVerb}
 \mbox{\Hypertarget{namespace__pytest_1_1compat_a7e7abdf5a8608ba2707053825e7818e8}\label{namespace__pytest_1_1compat_a7e7abdf5a8608ba2707053825e7818e8}} 
\index{\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}!safe\+\_\+getattr@{safe\+\_\+getattr}}
\index{safe\+\_\+getattr@{safe\+\_\+getattr}!\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}}
\subsubsection{\texorpdfstring{safe\+\_\+getattr()}{safe\_getattr()}}
{\footnotesize\ttfamily def \+\_\+pytest.\+compat.\+safe\+\_\+getattr (\begin{DoxyParamCaption}\item[{}]{object,  }\item[{}]{name,  }\item[{}]{default }\end{DoxyParamCaption})}

\begin{DoxyVerb}Like getattr but return default upon any Exception or any OutcomeException.

Attribute access can potentially fail for 'evil' Python objects.
See issue #214.
It catches OutcomeException because of #2490 (issue #580), new outcomes are derived from BaseException
instead of Exception (for more details check #2707)
\end{DoxyVerb}
 \mbox{\Hypertarget{namespace__pytest_1_1compat_ada77abd26b1ef5408c324cba3d9614d3}\label{namespace__pytest_1_1compat_ada77abd26b1ef5408c324cba3d9614d3}} 
\index{\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}!safe\+\_\+str@{safe\+\_\+str}}
\index{safe\+\_\+str@{safe\+\_\+str}!\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}}
\subsubsection{\texorpdfstring{safe\+\_\+str()}{safe\_str()}}
{\footnotesize\ttfamily def \+\_\+pytest.\+compat.\+safe\+\_\+str (\begin{DoxyParamCaption}\item[{}]{v }\end{DoxyParamCaption})}

\begin{DoxyVerb}returns v as string\end{DoxyVerb}


\begin{DoxyVerb}returns v as string, converting to ascii if necessary\end{DoxyVerb}
 

\subsection{Variable Documentation}
\mbox{\Hypertarget{namespace__pytest_1_1compat_ac7925fdc089c3e62d7da95406b4c0d9d}\label{namespace__pytest_1_1compat_ac7925fdc089c3e62d7da95406b4c0d9d}} 
\index{\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}!C\+O\+L\+L\+E\+C\+T\+\_\+\+F\+A\+K\+E\+M\+O\+D\+U\+L\+E\+\_\+\+A\+T\+T\+R\+I\+B\+U\+T\+ES@{C\+O\+L\+L\+E\+C\+T\+\_\+\+F\+A\+K\+E\+M\+O\+D\+U\+L\+E\+\_\+\+A\+T\+T\+R\+I\+B\+U\+T\+ES}}
\index{C\+O\+L\+L\+E\+C\+T\+\_\+\+F\+A\+K\+E\+M\+O\+D\+U\+L\+E\+\_\+\+A\+T\+T\+R\+I\+B\+U\+T\+ES@{C\+O\+L\+L\+E\+C\+T\+\_\+\+F\+A\+K\+E\+M\+O\+D\+U\+L\+E\+\_\+\+A\+T\+T\+R\+I\+B\+U\+T\+ES}!\+\_\+pytest\+::compat@{\+\_\+pytest\+::compat}}
\subsubsection{\texorpdfstring{C\+O\+L\+L\+E\+C\+T\+\_\+\+F\+A\+K\+E\+M\+O\+D\+U\+L\+E\+\_\+\+A\+T\+T\+R\+I\+B\+U\+T\+ES}{COLLECT\_FAKEMODULE\_ATTRIBUTES}}
{\footnotesize\ttfamily tuple \+\_\+pytest.\+compat.\+C\+O\+L\+L\+E\+C\+T\+\_\+\+F\+A\+K\+E\+M\+O\+D\+U\+L\+E\+\_\+\+A\+T\+T\+R\+I\+B\+U\+T\+ES}

{\bfseries Initial value\+:}
\begin{DoxyCode}
1 =  (
2     \textcolor{stringliteral}{"Collector"},
3     \textcolor{stringliteral}{"Module"},
4     \textcolor{stringliteral}{"Generator"},
5     \textcolor{stringliteral}{"Function"},
6     \textcolor{stringliteral}{"Instance"},
7     \textcolor{stringliteral}{"Session"},
8     \textcolor{stringliteral}{"Item"},
9     \textcolor{stringliteral}{"Class"},
10     \textcolor{stringliteral}{"File"},
11     \textcolor{stringliteral}{"\_fillfuncargs"},
12 )
\end{DoxyCode}
