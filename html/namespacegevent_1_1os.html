<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: gevent.os Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacegevent_1_1os.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gevent.os Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afda17326a86efe283deb154009b8aac9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#afda17326a86efe283deb154009b8aac9">make_nonblocking</a> (fd)</td></tr>
<tr class="separator:afda17326a86efe283deb154009b8aac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb3b6b13b3e790a9a392746bd295ffb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#a2fb3b6b13b3e790a9a392746bd295ffb">nb_read</a> (fd, n)</td></tr>
<tr class="separator:a2fb3b6b13b3e790a9a392746bd295ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d656b3256c18d0db846822e129eafb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#a22d656b3256c18d0db846822e129eafb">nb_write</a> (fd, buf)</td></tr>
<tr class="separator:a22d656b3256c18d0db846822e129eafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ed3c20a04f75267ee2fe251c4358a9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#a49ed3c20a04f75267ee2fe251c4358a9">tp_read</a> (fd, n)</td></tr>
<tr class="separator:a49ed3c20a04f75267ee2fe251c4358a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda169fc047bb4cc04b25ea8f154aa7f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#abda169fc047bb4cc04b25ea8f154aa7f">tp_write</a> (fd, buf)</td></tr>
<tr class="separator:abda169fc047bb4cc04b25ea8f154aa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98835fac37df4bd17a1433f6c01daf6f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#a98835fac37df4bd17a1433f6c01daf6f">fork_gevent</a> ()</td></tr>
<tr class="separator:a98835fac37df4bd17a1433f6c01daf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d22bcbe03e198e484217634c2611b7e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#a7d22bcbe03e198e484217634c2611b7e">fork</a> ()</td></tr>
<tr class="separator:a7d22bcbe03e198e484217634c2611b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e04fb5e868290aae691fd3a3a85a77e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#a3e04fb5e868290aae691fd3a3a85a77e">forkpty_gevent</a> ()</td></tr>
<tr class="separator:a3e04fb5e868290aae691fd3a3a85a77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d51adddb408a122bc8137102f54653"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#a73d51adddb408a122bc8137102f54653">waitpid</a> (pid, options)</td></tr>
<tr class="separator:a73d51adddb408a122bc8137102f54653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536e814c326f318e9bae710344de11d6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#a536e814c326f318e9bae710344de11d6">fork_and_watch</a> (callback=None, loop=None, ref=False, <a class="el" href="namespacegevent_1_1os.html#a7d22bcbe03e198e484217634c2611b7e">fork</a>=<a class="el" href="namespacegevent_1_1os.html#a98835fac37df4bd17a1433f6c01daf6f">fork_gevent</a>)</td></tr>
<tr class="separator:a536e814c326f318e9bae710344de11d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5115239646d7bd6a10bf4c24d07926b3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#a5115239646d7bd6a10bf4c24d07926b3">forkpty_and_watch</a> (callback=None, loop=None, ref=False, forkpty=<a class="el" href="namespacegevent_1_1os.html#a3e04fb5e868290aae691fd3a3a85a77e">forkpty_gevent</a>)</td></tr>
<tr class="separator:a5115239646d7bd6a10bf4c24d07926b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333943be729b41ab9ebc1402d8fb7992"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#a333943be729b41ab9ebc1402d8fb7992">fork</a> (args, kwargs)</td></tr>
<tr class="separator:a333943be729b41ab9ebc1402d8fb7992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0301570240bde65a58985e2b60e15535"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#a0301570240bde65a58985e2b60e15535">forkpty</a> (args, kwargs)</td></tr>
<tr class="separator:a0301570240bde65a58985e2b60e15535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050db0adfdcdc0616ac36b1d9874d494"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegevent_1_1os.html#a050db0adfdcdc0616ac36b1d9874d494">forkpty</a> ()</td></tr>
<tr class="separator:a050db0adfdcdc0616ac36b1d9874d494"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aedc9a2148b4c38a4cfaebe522ab9efc7"><td class="memItemLeft" align="right" valign="top"><a id="aedc9a2148b4c38a4cfaebe522ab9efc7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EAGAIN</b> = getattr(errno, 'EAGAIN', 11)</td></tr>
<tr class="separator:aedc9a2148b4c38a4cfaebe522ab9efc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7aad9683af2405447fd413dfd0cea0c"><td class="memItemLeft" align="right" valign="top"><a id="ab7aad9683af2405447fd413dfd0cea0c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>fcntl</b> = None</td></tr>
<tr class="separator:ab7aad9683af2405447fd413dfd0cea0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4886d17856986449da59e9f9fef8603"><td class="memItemLeft" align="right" valign="top"><a id="ae4886d17856986449da59e9f9fef8603"></a>
list&#160;</td><td class="memItemRight" valign="bottom"><b>ignored_errors</b> = [EAGAIN, errno.EINTR]</td></tr>
<tr class="separator:ae4886d17856986449da59e9f9fef8603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be4b87919eec33aa018cdab5dc5c072"><td class="memItemLeft" align="right" valign="top"><a id="a4be4b87919eec33aa018cdab5dc5c072"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>forkpty</b> = <a class="el" href="namespacegevent_1_1os.html#a3e04fb5e868290aae691fd3a3a85a77e">forkpty_gevent</a></td></tr>
<tr class="separator:a4be4b87919eec33aa018cdab5dc5c072"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Low-level operating system functions from :mod:`os`.

Cooperative I/O
===============

This module provides cooperative versions of :func:`os.read` and
:func:`os.write`. These functions are *not* monkey-patched; you
must explicitly call them or monkey patch them yourself.

POSIX functions
---------------

On POSIX, non-blocking IO is available.

- :func:`nb_read`
- :func:`nb_write`
- :func:`make_nonblocking`

All Platforms
-------------

On non-POSIX platforms (e.g., Windows), non-blocking IO is not
available. On those platforms (and on POSIX), cooperative IO can
be done with the threadpool.

- :func:`tp_read`
- :func:`tp_write`

Child Processes
===============

The functions :func:`fork` and (on POSIX) :func:`forkpty` and :func:`waitpid` can be used
to manage child processes.

.. warning::

   Forking a process that uses greenlets does not eliminate all non-running
   greenlets. Any that were scheduled in the hub of the forking thread in the parent
   remain scheduled in the child; compare this to how normal threads operate. (This behaviour
   may change is a subsequent major release.)
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a7d22bcbe03e198e484217634c2611b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d22bcbe03e198e484217634c2611b7e">&#9670;&nbsp;</a></span>fork() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.fork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A wrapper for :func:`fork_gevent` for non-POSIX platforms.
</pre><pre class="fragment">Forks a child process, initializes gevent in the child,
but *does not* prepare the parent to wait for the child or receive SIGCHLD.

This implementation of ``fork`` is a wrapper for :func:`fork_gevent`
when the environment variable ``GEVENT_NOWAITPID`` *is* defined.
This is not recommended for most applications.
</pre> 
</div>
</div>
<a id="a333943be729b41ab9ebc1402d8fb7992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333943be729b41ab9ebc1402d8fb7992">&#9670;&nbsp;</a></span>fork() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.fork </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Forks a child process and starts a child watcher for it in the
parent process so that ``waitpid`` and SIGCHLD work as expected.

This implementation of ``fork`` is a wrapper for :func:`fork_and_watch`
when the environment variable ``GEVENT_NOWAITPID`` is *not* defined.
This is the default and should be used by most applications.

.. versionchanged:: 1.1b2
</pre> 
</div>
</div>
<a id="a536e814c326f318e9bae710344de11d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536e814c326f318e9bae710344de11d6">&#9670;&nbsp;</a></span>fork_and_watch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.fork_and_watch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>loop</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ref</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fork</em> = <code><a class="el" href="namespacegevent_1_1os.html#a98835fac37df4bd17a1433f6c01daf6f">fork_gevent</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Fork a child process and start a child watcher for it in the parent process.

This call cooperates with :func:`waitpid` to enable cooperatively waiting
for children to finish. When monkey-patching, these functions are patched in as
:func:`os.fork` and :func:`os.waitpid`, respectively.

In the child process, this function calls :func:`gevent.hub.reinit` before returning.

Availability: POSIX.

:keyword callback: If given, a callable that will be called with the child watcher
    when the child finishes.
:keyword loop: The loop to start the watcher in. Defaults to the
    loop of the current hub.
:keyword fork: The fork function. Defaults to :func:`the one defined in this
    module &lt;gevent.os.fork_gevent&gt;` (which automatically calls :func:`gevent.hub.reinit`).
    Pass the builtin :func:`os.fork` function if you do not need to
    initialize gevent in the child process.

.. versionadded:: 1.1b1
.. seealso::
    :func:`gevent.monkey.get_original` To access the builtin :func:`os.fork`.
</pre> 
</div>
</div>
<a id="a98835fac37df4bd17a1433f6c01daf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98835fac37df4bd17a1433f6c01daf6f">&#9670;&nbsp;</a></span>fork_gevent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.fork_gevent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Forks the process using :func:`os.fork` and prepares the
child process to continue using gevent before returning.

.. note::

    The PID returned by this function may not be waitable with
    either the original :func:`os.waitpid` or this module's
    :func:`waitpid` and it may not generate SIGCHLD signals if
    libev child watchers are or ever have been in use. For
    example, the :mod:`gevent.subprocess` module uses libev
    child watchers (which parts of gevent use libev child
    watchers is subject to change at any time). Most
    applications should use :func:`fork_and_watch`, which is
    monkey-patched as the default replacement for
    :func:`os.fork` and implements the ``fork`` function of
    this module by default, unless the environment variable
    ``GEVENT_NOWAITPID`` is defined before this module is
    imported.

.. versionadded:: 1.1b2
</pre> 
</div>
</div>
<a id="a0301570240bde65a58985e2b60e15535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0301570240bde65a58985e2b60e15535">&#9670;&nbsp;</a></span>forkpty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.forkpty </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Like :func:`fork`, but using :func:`forkpty_gevent`.

This implementation of ``forkpty`` is a wrapper for :func:`forkpty_and_watch`
when the environment variable ``GEVENT_NOWAITPID`` is *not* defined.
This is the default and should be used by most applications.

.. versionadded:: 1.1b5
</pre> 
</div>
</div>
<a id="a050db0adfdcdc0616ac36b1d9874d494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050db0adfdcdc0616ac36b1d9874d494">&#9670;&nbsp;</a></span>forkpty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.forkpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Like :func:`fork`, but using :func:`os.forkpty`

This implementation of ``forkpty`` is a wrapper for :func:`forkpty_gevent`
when the environment variable ``GEVENT_NOWAITPID`` *is* defined.
This is not recommended for most applications.

.. versionadded:: 1.1b5
</pre> 
</div>
</div>
<a id="a5115239646d7bd6a10bf4c24d07926b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5115239646d7bd6a10bf4c24d07926b3">&#9670;&nbsp;</a></span>forkpty_and_watch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.forkpty_and_watch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>loop</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ref</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>forkpty</em> = <code><a class="el" href="namespacegevent_1_1os.html#a3e04fb5e868290aae691fd3a3a85a77e">forkpty_gevent</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Like :func:`fork_and_watch`, except using :func:`forkpty_gevent`.

Availability: Some Unix systems.

.. versionadded:: 1.1b5
</pre> 
</div>
</div>
<a id="a3e04fb5e868290aae691fd3a3a85a77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e04fb5e868290aae691fd3a3a85a77e">&#9670;&nbsp;</a></span>forkpty_gevent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.forkpty_gevent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Forks the process using :func:`os.forkpty` and prepares the
child process to continue using gevent before returning.

Returns a tuple (pid, master_fd). The `master_fd` is *not* put into
non-blocking mode.

Availability: Some Unix systems.

.. seealso:: This function has the same limitations as :func:`fork_gevent`.

.. versionadded:: 1.1b5
</pre> 
</div>
</div>
<a id="afda17326a86efe283deb154009b8aac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda17326a86efe283deb154009b8aac9">&#9670;&nbsp;</a></span>make_nonblocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.make_nonblocking </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Put the file descriptor *fd* into non-blocking mode if
possible.

:return: A boolean value that evaluates to True if successful.
</pre> 
</div>
</div>
<a id="a2fb3b6b13b3e790a9a392746bd295ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb3b6b13b3e790a9a392746bd295ffb">&#9670;&nbsp;</a></span>nb_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.nb_read </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read up to *n* bytes from file descriptor *fd*. Return a
byte string containing the bytes read, which may be shorter than
*n*. If end-of-file is reached, an empty string is returned.

The descriptor must be in non-blocking mode.
</pre> 
</div>
</div>
<a id="a22d656b3256c18d0db846822e129eafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d656b3256c18d0db846822e129eafb">&#9670;&nbsp;</a></span>nb_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.nb_write </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write some number of bytes from buffer *buf* to file
descriptor *fd*. Return the number of bytes written, which may
be less than the length of *buf*.

The file descriptor must be in non-blocking mode.
</pre> 
</div>
</div>
<a id="a49ed3c20a04f75267ee2fe251c4358a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ed3c20a04f75267ee2fe251c4358a9">&#9670;&nbsp;</a></span>tp_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.tp_read </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read up to *n* bytes from file descriptor *fd*. Return a string
containing the bytes read. If end-of-file is reached, an empty string
is returned.

Reading is done using the threadpool.
</pre> 
</div>
</div>
<a id="abda169fc047bb4cc04b25ea8f154aa7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda169fc047bb4cc04b25ea8f154aa7f">&#9670;&nbsp;</a></span>tp_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.tp_write </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write bytes from buffer *buf* to file descriptor *fd*. Return the
number of bytes written.

Writing is done using the threadpool.
</pre> 
</div>
</div>
<a id="a73d51adddb408a122bc8137102f54653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d51adddb408a122bc8137102f54653">&#9670;&nbsp;</a></span>waitpid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.os.waitpid </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wait for a child process to finish.

If the child process was spawned using
:func:`fork_and_watch`, then this function behaves
cooperatively. If not, it *may* have race conditions; see
:func:`fork_gevent` for more information.

The arguments are as for the underlying
:func:`os.waitpid`. Some combinations of *options* may not
be supported cooperatively (as of 1.1 that includes
WUNTRACED). Using a *pid* of 0 to request waiting on only processes
from the current process group is not cooperative.

Availability: POSIX.

.. versionadded:: 1.1b1
.. versionchanged:: 1.2a1
   More cases are handled in a cooperative manner.
</pre> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>gevent</b></li><li class="navelem"><a class="el" href="namespacegevent_1_1os.html">os</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
