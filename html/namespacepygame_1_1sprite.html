<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: pygame.sprite Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacepygame_1_1sprite.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pygame.sprite Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpygame_1_1sprite_1_1_abstract_group.html">AbstractGroup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpygame_1_1sprite_1_1collide__circle__ratio.html">collide_circle_ratio</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpygame_1_1sprite_1_1collide__rect__ratio.html">collide_rect_ratio</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpygame_1_1sprite_1_1_dirty_sprite.html">DirtySprite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpygame_1_1sprite_1_1_group.html">Group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpygame_1_1sprite_1_1_group_single.html">GroupSingle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpygame_1_1sprite_1_1_layered_dirty.html">LayeredDirty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpygame_1_1sprite_1_1_layered_updates.html">LayeredUpdates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpygame_1_1sprite_1_1_ordered_updates.html">OrderedUpdates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpygame_1_1sprite_1_1_render_updates.html">RenderUpdates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpygame_1_1sprite_1_1_sprite.html">Sprite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac3dd48705499b86a7214761b75380981"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#ac3dd48705499b86a7214761b75380981">clear</a> (self, surface, bgd)</td></tr>
<tr class="memdesc:ac3dd48705499b86a7214761b75380981"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h1>debug</h1>
print "               check: using dirty rects:", self._use_update  <a href="#ac3dd48705499b86a7214761b75380981">More...</a><br /></td></tr>
<tr class="separator:ac3dd48705499b86a7214761b75380981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63faa0befe41ad5ed3c2c970a735275"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#af63faa0befe41ad5ed3c2c970a735275">repaint_rect</a> (self, screen_rect)</td></tr>
<tr class="separator:af63faa0befe41ad5ed3c2c970a735275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2724cd881e8ebb2a5f1f01e9d641a7f2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#a2724cd881e8ebb2a5f1f01e9d641a7f2">set_clip</a> (self, screen_rect=None)</td></tr>
<tr class="separator:a2724cd881e8ebb2a5f1f01e9d641a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60842ea8d65ad8db56c52b1f6f90de29"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#a60842ea8d65ad8db56c52b1f6f90de29">get_clip</a> (self)</td></tr>
<tr class="separator:a60842ea8d65ad8db56c52b1f6f90de29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382eb838f5cdf51df1202a0f3350f8fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#a382eb838f5cdf51df1202a0f3350f8fc">change_layer</a> (self, <a class="el" href="namespacepygame.html#aa4b7d2ae8175850dd21d2b548f184cb8">sprite</a>, new_layer)</td></tr>
<tr class="separator:a382eb838f5cdf51df1202a0f3350f8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900a993afbcd946ffcd9af8f54154b8f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#a900a993afbcd946ffcd9af8f54154b8f">set_timing_treshold</a> (self, time_ms)</td></tr>
<tr class="separator:a900a993afbcd946ffcd9af8f54154b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38539bf4d7efe1157a864e4ecb9b5237"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#a38539bf4d7efe1157a864e4ecb9b5237">collide_rect</a> (left, right)</td></tr>
<tr class="separator:a38539bf4d7efe1157a864e4ecb9b5237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e8ebb1118757911e5fc2931aebf494"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#a69e8ebb1118757911e5fc2931aebf494">collide_circle</a> (left, right)</td></tr>
<tr class="separator:a69e8ebb1118757911e5fc2931aebf494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac070f5d4ef6163636321a2a0ba458dcb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#ac070f5d4ef6163636321a2a0ba458dcb">collide_mask</a> (left, right)</td></tr>
<tr class="separator:ac070f5d4ef6163636321a2a0ba458dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68d7d247355b00f22e3dc6b84b92dfb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#aa68d7d247355b00f22e3dc6b84b92dfb">spritecollide</a> (<a class="el" href="namespacepygame.html#aa4b7d2ae8175850dd21d2b548f184cb8">sprite</a>, group, dokill, collided=None)</td></tr>
<tr class="separator:aa68d7d247355b00f22e3dc6b84b92dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cf4fd668b1d579f5d1385739e52851"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#aa6cf4fd668b1d579f5d1385739e52851">groupcollide</a> (groupa, groupb, dokilla, dokillb, collided=None)</td></tr>
<tr class="separator:aa6cf4fd668b1d579f5d1385739e52851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25941b8c21cff8ba445e32266ba1282d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#a25941b8c21cff8ba445e32266ba1282d">spritecollideany</a> (<a class="el" href="namespacepygame.html#aa4b7d2ae8175850dd21d2b548f184cb8">sprite</a>, group, collided=None)</td></tr>
<tr class="separator:a25941b8c21cff8ba445e32266ba1282d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a800dcabe3c7d87b3e8f22bcbb204bf22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#a800dcabe3c7d87b3e8f22bcbb204bf22">callable</a> = lambda obj: hasattr(obj, '__call__')</td></tr>
<tr class="separator:a800dcabe3c7d87b3e8f22bcbb204bf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e060a482e09d1a567cb7356c2cf4a33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#a3e060a482e09d1a567cb7356c2cf4a33">RenderPlain</a> = <a class="el" href="classpygame_1_1sprite_1_1_group.html">Group</a></td></tr>
<tr class="separator:a3e060a482e09d1a567cb7356c2cf4a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809335dc88fa487b290217358e9638d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepygame_1_1sprite.html#a809335dc88fa487b290217358e9638d7">RenderClear</a> = <a class="el" href="classpygame_1_1sprite_1_1_group.html">Group</a></td></tr>
<tr class="separator:a809335dc88fa487b290217358e9638d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a382eb838f5cdf51df1202a0f3350f8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382eb838f5cdf51df1202a0f3350f8fc">&#9670;&nbsp;</a></span>change_layer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pygame.sprite.change_layer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sprite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>new_layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">change the layer of the sprite

LayeredUpdates.change_layer(sprite, new_layer): return None

The sprite must have been added to the renderer already. This is not
checked.</pre> 
</div>
</div>
<a id="ac3dd48705499b86a7214761b75380981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dd48705499b86a7214761b75380981">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pygame.sprite.clear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bgd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><h1>debug</h1>
print "               check: using dirty rects:", self._use_update </p>
<pre class="fragment">use to set background

Group.clear(surface, bgd): return None</pre> 
</div>
</div>
<a id="a69e8ebb1118757911e5fc2931aebf494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e8ebb1118757911e5fc2931aebf494">&#9670;&nbsp;</a></span>collide_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pygame.sprite.collide_circle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">detect collision between two sprites using circles

pygame.sprite.collide_circle(left, right): return bool

Tests for collision between two sprites by testing whether two circles
centered on the sprites overlap. If the sprites have a "radius" attribute,
then that radius is used to create the circle; otherwise, a circle is
created that is big enough to completely enclose the sprite's rect as
given by the "rect" attribute. This function is intended to be passed as
a collided callback function to the *collide functions. Sprites must have a
"rect" and an optional "radius" attribute.

New in pygame 1.8.0</pre> 
</div>
</div>
<a id="ac070f5d4ef6163636321a2a0ba458dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac070f5d4ef6163636321a2a0ba458dcb">&#9670;&nbsp;</a></span>collide_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pygame.sprite.collide_mask </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">collision detection between two sprites, using masks.

pygame.sprite.collide_mask(SpriteLeft, SpriteRight): bool

Tests for collision between two sprites by testing if their bitmasks
overlap. If the sprites have a "mask" attribute, that is used as the mask;
otherwise, a mask is created from the sprite image. Intended to be passed
as a collided callback function to the *collide functions. Sprites must
have a "rect" and an optional "mask" attribute.

New in pygame 1.8.0</pre> 
</div>
</div>
<a id="a38539bf4d7efe1157a864e4ecb9b5237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38539bf4d7efe1157a864e4ecb9b5237">&#9670;&nbsp;</a></span>collide_rect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pygame.sprite.collide_rect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">collision detection between two sprites, using rects.

pygame.sprite.collide_rect(left, right): return bool

Tests for collision between two sprites. Uses the pygame.Rect colliderect
function to calculate the collision. It is intended to be passed as a
collided callback function to the *collide functions. Sprites must have
"rect" attributes.

New in pygame 1.8.0</pre> 
</div>
</div>
<a id="a60842ea8d65ad8db56c52b1f6f90de29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60842ea8d65ad8db56c52b1f6f90de29">&#9670;&nbsp;</a></span>get_clip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pygame.sprite.get_clip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">get the area where drawing will occur

LayeredDirty.get_clip(): return Rect</pre> 
</div>
</div>
<a id="aa6cf4fd668b1d579f5d1385739e52851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cf4fd668b1d579f5d1385739e52851">&#9670;&nbsp;</a></span>groupcollide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pygame.sprite.groupcollide </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>groupa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>groupb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dokilla</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dokillb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>collided</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">detect collision between a group and another group

pygame.sprite.groupcollide(groupa, groupb, dokilla, dokillb):
    return dict

Given two groups, this will find the intersections between all sprites in
each group. It returns a dictionary of all sprites in the first group that
collide. The value for each item in the dictionary is a list of the sprites
in the second group it collides with. The two dokill arguments control if
the sprites from either group will be automatically removed from all
groups. Collided is a callback function used to calculate if two sprites
are colliding. it should take two sprites as values, and return a bool
value indicating if they are colliding. If collided is not passed, all
sprites must have a "rect" value, which is a rectangle of the sprite area
that will be used to calculate the collision.</pre> 
</div>
</div>
<a id="af63faa0befe41ad5ed3c2c970a735275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63faa0befe41ad5ed3c2c970a735275">&#9670;&nbsp;</a></span>repaint_rect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pygame.sprite.repaint_rect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>screen_rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">repaint the given area

LayeredDirty.repaint_rect(screen_rect): return None

screen_rect is in screen coordinates.</pre> 
</div>
</div>
<a id="a2724cd881e8ebb2a5f1f01e9d641a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2724cd881e8ebb2a5f1f01e9d641a7f2">&#9670;&nbsp;</a></span>set_clip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pygame.sprite.set_clip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>screen_rect</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">clip the area where to draw; pass None (default) to reset the clip

LayeredDirty.set_clip(screen_rect=None): return None</pre> 
</div>
</div>
<a id="a900a993afbcd946ffcd9af8f54154b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900a993afbcd946ffcd9af8f54154b8f">&#9670;&nbsp;</a></span>set_timing_treshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pygame.sprite.set_timing_treshold </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">set the treshold in milliseconds

set_timing_treshold(time_ms): return None

Defaults to 1000.0 / 80.0. This means that the screen will be painted
using the flip method rather than the update method if the update
method is taking so long to update the screen that the frame rate falls
below 80 frames per second.</pre> 
</div>
</div>
<a id="aa68d7d247355b00f22e3dc6b84b92dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68d7d247355b00f22e3dc6b84b92dfb">&#9670;&nbsp;</a></span>spritecollide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pygame.sprite.spritecollide </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sprite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dokill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>collided</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">find Sprites in a Group that intersect another Sprite

pygame.sprite.spritecollide(sprite, group, dokill, collided=None):
    return Sprite_list

Return a list containing all Sprites in a Group that intersect with another
Sprite. Intersection is determined by comparing the Sprite.rect attribute
of each Sprite.

The dokill argument is a bool. If set to True, all Sprites that collide
will be removed from the Group.

The collided argument is a callback function used to calculate if two
sprites are colliding. it should take two sprites as values, and return a
bool value indicating if they are colliding. If collided is not passed, all
sprites must have a "rect" value, which is a rectangle of the sprite area,
which will be used to calculate the collision.</pre> 
</div>
</div>
<a id="a25941b8c21cff8ba445e32266ba1282d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25941b8c21cff8ba445e32266ba1282d">&#9670;&nbsp;</a></span>spritecollideany()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def pygame.sprite.spritecollideany </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sprite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>collided</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">finds any sprites in a group that collide with the given sprite

pygame.sprite.spritecollideany(sprite, group): return sprite

Given a sprite and a group of sprites, this will return return any single
sprite that collides with with the given sprite. If there are no
collisions, then this returns None.

If you don't need all the features of the spritecollide function, this
function will be a bit quicker.

Collided is a callback function used to calculate if two sprites are
colliding. It should take two sprites as values and return a bool value
indicating if they are colliding. If collided is not passed, then all
sprites must have a "rect" value, which is a rectangle of the sprite area,
which will be used to calculate the collision.</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a800dcabe3c7d87b3e8f22bcbb204bf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800dcabe3c7d87b3e8f22bcbb204bf22">&#9670;&nbsp;</a></span>callable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pygame.sprite.callable = lambda obj: hasattr(obj, '__call__')</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a809335dc88fa487b290217358e9638d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809335dc88fa487b290217358e9638d7">&#9670;&nbsp;</a></span>RenderClear</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pygame.sprite.RenderClear = <a class="el" href="classpygame_1_1sprite_1_1_group.html">Group</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e060a482e09d1a567cb7356c2cf4a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e060a482e09d1a567cb7356c2cf4a33">&#9670;&nbsp;</a></span>RenderPlain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pygame.sprite.RenderPlain = <a class="el" href="classpygame_1_1sprite_1_1_group.html">Group</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepygame.html">pygame</a></li><li class="navelem"><a class="el" href="namespacepygame_1_1sprite.html">sprite</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
