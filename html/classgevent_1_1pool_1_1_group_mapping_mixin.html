<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: gevent.pool.GroupMappingMixin Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgevent_1_1pool_1_1_group_mapping_mixin.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgevent_1_1pool_1_1_group_mapping_mixin-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gevent.pool.GroupMappingMixin Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inherits object.</p>

<p>Inherited by <a class="el" href="classgevent_1_1pool_1_1_group.html">gevent.pool.Group</a>, and <a class="el" href="classgevent_1_1threadpool_1_1_thread_pool.html">gevent.threadpool.ThreadPool</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aef5d85d8e23d7d009a47555e75040034"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevent_1_1pool_1_1_group_mapping_mixin.html#aef5d85d8e23d7d009a47555e75040034">spawn</a> (self, func, args, kwargs)</td></tr>
<tr class="separator:aef5d85d8e23d7d009a47555e75040034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c630e95bd357dadd9dc1e1ab86acc8f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevent_1_1pool_1_1_group_mapping_mixin.html#a3c630e95bd357dadd9dc1e1ab86acc8f">apply_cb</a> (self, func, args=None, kwds=None, callback=None)</td></tr>
<tr class="separator:a3c630e95bd357dadd9dc1e1ab86acc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941dbbc427759802773477a43b800e6e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevent_1_1pool_1_1_group_mapping_mixin.html#a941dbbc427759802773477a43b800e6e">apply_async</a> (self, func, args=None, kwds=None, callback=None)</td></tr>
<tr class="separator:a941dbbc427759802773477a43b800e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041583aabc35041a8e43ccde41e574a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevent_1_1pool_1_1_group_mapping_mixin.html#a041583aabc35041a8e43ccde41e574a2">apply</a> (self, func, args=None, kwds=None)</td></tr>
<tr class="separator:a041583aabc35041a8e43ccde41e574a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98092e4962dda9badad51318f2a2112"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevent_1_1pool_1_1_group_mapping_mixin.html#ab98092e4962dda9badad51318f2a2112">map</a> (self, func, iterable)</td></tr>
<tr class="separator:ab98092e4962dda9badad51318f2a2112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab386743e92655a00cba1199588a072fa"><td class="memItemLeft" align="right" valign="top"><a id="ab386743e92655a00cba1199588a072fa"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>map_cb</b> (self, func, iterable, callback=None)</td></tr>
<tr class="separator:ab386743e92655a00cba1199588a072fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911ffc786f9671500b344a461d4527ba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevent_1_1pool_1_1_group_mapping_mixin.html#a911ffc786f9671500b344a461d4527ba">map_async</a> (self, func, iterable, callback=None)</td></tr>
<tr class="separator:a911ffc786f9671500b344a461d4527ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1b1d6ed667a020a99cc9c86fadf785"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevent_1_1pool_1_1_group_mapping_mixin.html#a0c1b1d6ed667a020a99cc9c86fadf785">imap</a> (self, func, iterables, kwargs)</td></tr>
<tr class="separator:a0c1b1d6ed667a020a99cc9c86fadf785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2631d27e737e675bea211e4b5576325f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgevent_1_1pool_1_1_group_mapping_mixin.html#a2631d27e737e675bea211e4b5576325f">imap_unordered</a> (self, func, iterables, kwargs)</td></tr>
<tr class="separator:a2631d27e737e675bea211e4b5576325f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a041583aabc35041a8e43ccde41e574a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041583aabc35041a8e43ccde41e574a2">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.pool.GroupMappingMixin.apply </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwds</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rough quivalent of the :func:`apply()` builtin function blocking until
the result is ready and returning it.

The ``func`` will *usually*, but not *always*, be run in a way
that allows the current greenlet to switch out (for example,
in a new greenlet or thread, depending on implementation). But
if the current greenlet or thread is already one that was
spawned by this pool, the pool may choose to immediately run
the `func` synchronously.

Any exception ``func`` raises will be propagated to the caller of ``apply`` (that is,
this method will raise the exception that ``func`` raised).
</pre> 
</div>
</div>
<a id="a941dbbc427759802773477a43b800e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941dbbc427759802773477a43b800e6e">&#9670;&nbsp;</a></span>apply_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.pool.GroupMappingMixin.apply_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A variant of the :meth:`apply` method which returns a :class:`~.Greenlet` object.

When the returned greenlet gets to run, it *will* call :meth:`apply`,
passing in *func*, *args* and *kwds*.

If *callback* is specified, then it should be a callable which
accepts a single argument. When the result becomes ready
callback is applied to it (unless the call failed).

This method will never block, even if this group is full (that is,
even if :meth:`spawn` would block, this method will not).

.. caution:: The returned greenlet may or may not be tracked
   as part of this group, so :meth:`joining &lt;join&gt;` this group is
   not a reliable way to wait for the results to be available or
   for the returned greenlet to run; instead, join the returned
   greenlet.

.. tip:: Because :class:`~.ThreadPool` objects do not track greenlets, the returned
   greenlet will never be a part of it. To reduce overhead and improve performance,
   :class:`Group` and :class:`Pool` may choose to track the returned
   greenlet. These are implementation details that may change.
</pre> 
</div>
</div>
<a id="a3c630e95bd357dadd9dc1e1ab86acc8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c630e95bd357dadd9dc1e1ab86acc8f">&#9670;&nbsp;</a></span>apply_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.pool.GroupMappingMixin.apply_cb </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwds</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">:meth:`apply` the given *func(\\*args, \\*\\*kwds)*, and, if a *callback* is given, run it with the
results of *func* (unless an exception was raised.)

The *callback* may be called synchronously or asynchronously. If called
asynchronously, it will not be tracked by this group. (:class:`Group` and :class:`Pool`
call it asynchronously in a new greenlet; :class:`~gevent.threadpool.ThreadPool` calls
it synchronously in the current greenlet.)
</pre> 
</div>
</div>
<a id="a0c1b1d6ed667a020a99cc9c86fadf785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1b1d6ed667a020a99cc9c86fadf785">&#9670;&nbsp;</a></span>imap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.pool.GroupMappingMixin.imap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">imap(func, *iterables, maxsize=None) -&gt; iterable

An equivalent of :func:`itertools.imap`, operating in parallel.
The *func* is applied to each element yielded from each
iterable in *iterables* in turn, collecting the result.

If this object has a bound on the number of active greenlets it can
contain (such as :class:`Pool`), then at most that number of tasks will operate
in parallel.

:keyword int maxsize: If given and not-None, specifies the maximum number of
    finished results that will be allowed to accumulate awaiting the reader;
    more than that number of results will cause map function greenlets to begin
    to block. This is most useful if there is a great disparity in the speed of
    the mapping code and the consumer and the results consume a great deal of resources.

    .. note:: This is separate from any bound on the number of active parallel
       tasks, though they may have some interaction (for example, limiting the
       number of parallel tasks to the smallest bound).

    .. note:: Using a bound is slightly more computationally expensive than not using a bound.

    .. tip:: The :meth:`imap_unordered` method makes much better
use of this parameter. Some additional, unspecified,
number of objects may be required to be kept in memory
to maintain order by this function.

:return: An iterable object.

.. versionchanged:: 1.1b3
    Added the *maxsize* keyword parameter.
.. versionchanged:: 1.1a1
    Accept multiple *iterables* to iterate in parallel.
</pre> 
</div>
</div>
<a id="a2631d27e737e675bea211e4b5576325f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2631d27e737e675bea211e4b5576325f">&#9670;&nbsp;</a></span>imap_unordered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.pool.GroupMappingMixin.imap_unordered </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">imap_unordered(func, *iterables, maxsize=None) -&gt; iterable

The same as :meth:`imap` except that the ordering of the results
from the returned iterator should be considered in arbitrary
order.

This is lighter weight than :meth:`imap` and should be preferred if order
doesn't matter.

.. seealso:: :meth:`imap` for more details.
</pre> 
</div>
</div>
<a id="ab98092e4962dda9badad51318f2a2112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98092e4962dda9badad51318f2a2112">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.pool.GroupMappingMixin.map </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list made by applying the *func* to each element of
the iterable.

.. seealso:: :meth:`imap`
</pre> 
</div>
</div>
<a id="a911ffc786f9671500b344a461d4527ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911ffc786f9671500b344a461d4527ba">&#9670;&nbsp;</a></span>map_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.pool.GroupMappingMixin.map_async </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A variant of the map() method which returns a Greenlet object that is executing
the map function.

If callback is specified then it should be a callable which accepts a
single argument.
</pre> 
</div>
</div>
<a id="aef5d85d8e23d7d009a47555e75040034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5d85d8e23d7d009a47555e75040034">&#9670;&nbsp;</a></span>spawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def gevent.pool.GroupMappingMixin.spawn </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A function that runs *func* with *args* and *kwargs*, potentially
asynchronously. Return a value with a ``get`` method that blocks
until the results of func are available, and a ``rawlink`` method
that calls a callback when the results are available.

If this object has an upper bound on how many asyncronously executing
tasks can exist, this method may block until a slot becomes available.
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>venv/lib/python3.6/site-packages/gevent/pool.py</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>gevent</b></li><li class="navelem"><b>pool</b></li><li class="navelem"><a class="el" href="classgevent_1_1pool_1_1_group_mapping_mixin.html">GroupMappingMixin</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
