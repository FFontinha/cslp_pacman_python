<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: websockets.protocol.WebSocketCommonProtocol Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">websockets.protocol.WebSocketCommonProtocol Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inherits StreamReaderProtocol.</p>

<p>Inherited by <a class="el" href="classwebsockets_1_1client_1_1_web_socket_client_protocol.html">websockets.client.WebSocketClientProtocol</a>, and <a class="el" href="classwebsockets_1_1server_1_1_web_socket_server_protocol.html">websockets.server.WebSocketServerProtocol</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3974c237e95cb781821851d300c72ada"><td class="memItemLeft" align="right" valign="top"><a id="a3974c237e95cb781821851d300c72ada"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__init__</b> (self, host=None, port=None, secure=None, timeout=10, max_size=2 **20, max_queue=2 **5, read_limit=2 **16, write_limit=2 **16, loop=None, legacy_recv=False)</td></tr>
<tr class="separator:a3974c237e95cb781821851d300c72ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe4c82f5ec19977f55679023ac608fb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#aefe4c82f5ec19977f55679023ac608fb">client_connected</a> (self, reader, writer)</td></tr>
<tr class="separator:aefe4c82f5ec19977f55679023ac608fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae85117dc05aa48fa6de503bab27fef5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#aae85117dc05aa48fa6de503bab27fef5">connection_open</a> (self)</td></tr>
<tr class="separator:aae85117dc05aa48fa6de503bab27fef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147f81a594cc1d7f952a90800283ff2d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a147f81a594cc1d7f952a90800283ff2d">local_address</a> (self)</td></tr>
<tr class="separator:a147f81a594cc1d7f952a90800283ff2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8d78c5c3d633d9636ffd773de87ae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a9eb8d78c5c3d633d9636ffd773de87ae">remote_address</a> (self)</td></tr>
<tr class="separator:a9eb8d78c5c3d633d9636ffd773de87ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac646626706d4fea1e2ac92c056d1b572"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#ac646626706d4fea1e2ac92c056d1b572">open</a> (self)</td></tr>
<tr class="separator:ac646626706d4fea1e2ac92c056d1b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bc1f93413a8480ae83af00848d89f6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a52bc1f93413a8480ae83af00848d89f6">closed</a> (self)</td></tr>
<tr class="separator:a52bc1f93413a8480ae83af00848d89f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98319d5e461fef80290790f0bfbb51f2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a98319d5e461fef80290790f0bfbb51f2">recv</a> (self)</td></tr>
<tr class="separator:a98319d5e461fef80290790f0bfbb51f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d893d014ed4d263ac98d1bf6034caf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a18d893d014ed4d263ac98d1bf6034caf">send</a> (self, data)</td></tr>
<tr class="separator:a18d893d014ed4d263ac98d1bf6034caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff205f28fde8948f321c8115696fea5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a0ff205f28fde8948f321c8115696fea5">close</a> (self, code=1000, reason='')</td></tr>
<tr class="separator:a0ff205f28fde8948f321c8115696fea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660f3e46bbe578a1c624c544bf3e9e87"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a660f3e46bbe578a1c624c544bf3e9e87">ping</a> (self, data=None)</td></tr>
<tr class="separator:a660f3e46bbe578a1c624c544bf3e9e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac0bd94a1cf0015cb0aa687daf78676"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#aaac0bd94a1cf0015cb0aa687daf78676">pong</a> (self, data=b'')</td></tr>
<tr class="separator:aaac0bd94a1cf0015cb0aa687daf78676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bfc837fed80493c2196001363cc1d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a35bfc837fed80493c2196001363cc1d4">ensure_open</a> (self)</td></tr>
<tr class="separator:a35bfc837fed80493c2196001363cc1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a6c3c50dd1f87096a3f191780d9c2c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a07a6c3c50dd1f87096a3f191780d9c2c">transfer_data</a> (self)</td></tr>
<tr class="separator:a07a6c3c50dd1f87096a3f191780d9c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de6a491a4d3bb17bdd6ede36c3ad114"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a4de6a491a4d3bb17bdd6ede36c3ad114">read_message</a> (self)</td></tr>
<tr class="separator:a4de6a491a4d3bb17bdd6ede36c3ad114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0736093eb665ea46a97730d255173cb9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a0736093eb665ea46a97730d255173cb9">read_data_frame</a> (self, max_size)</td></tr>
<tr class="separator:a0736093eb665ea46a97730d255173cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8d236293e7897c4574b63f25d65fae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a8d8d236293e7897c4574b63f25d65fae">read_frame</a> (self, max_size)</td></tr>
<tr class="separator:a8d8d236293e7897c4574b63f25d65fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b560dfc332d9854875a8787c50fafe4"><td class="memItemLeft" align="right" valign="top"><a id="a8b560dfc332d9854875a8787c50fafe4"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>write_frame</b> (self, opcode, data=b'', _expected_state=State.OPEN)</td></tr>
<tr class="separator:a8b560dfc332d9854875a8787c50fafe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8c8138e1b8a415fdfd3996cb1e7196"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#abc8c8138e1b8a415fdfd3996cb1e7196">writer_is_closing</a> (self)</td></tr>
<tr class="separator:abc8c8138e1b8a415fdfd3996cb1e7196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1634532917578e526a294c1c94c81914"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a1634532917578e526a294c1c94c81914">write_close_frame</a> (self, data=b'')</td></tr>
<tr class="separator:a1634532917578e526a294c1c94c81914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93f2de9e4d230c3651683245140f55a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#ab93f2de9e4d230c3651683245140f55a">close_connection</a> (self)</td></tr>
<tr class="separator:ab93f2de9e4d230c3651683245140f55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da1c941470085c421ae779bbfef40bb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a0da1c941470085c421ae779bbfef40bb">wait_for_connection_lost</a> (self)</td></tr>
<tr class="separator:a0da1c941470085c421ae779bbfef40bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618b79d4fa0be44b89561f8abab709e1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a618b79d4fa0be44b89561f8abab709e1">fail_connection</a> (self, code=1006, reason='')</td></tr>
<tr class="separator:a618b79d4fa0be44b89561f8abab709e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b650d7fe663c9465e7fc027689cad4e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a8b650d7fe663c9465e7fc027689cad4e">connection_made</a> (self, transport)</td></tr>
<tr class="separator:a8b650d7fe663c9465e7fc027689cad4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b5889a53c9bbb91fe209627c321297"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a10b5889a53c9bbb91fe209627c321297">eof_received</a> (self)</td></tr>
<tr class="separator:a10b5889a53c9bbb91fe209627c321297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726b03e5dfb763929cd619a768b7acd0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html#a726b03e5dfb763929cd619a768b7acd0">connection_lost</a> (self, exc)</td></tr>
<tr class="separator:a726b03e5dfb763929cd619a768b7acd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a66b1861a2580a872a901a874ea6b954f"><td class="memItemLeft" align="right" valign="top"><a id="a66b1861a2580a872a901a874ea6b954f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>host</b></td></tr>
<tr class="separator:a66b1861a2580a872a901a874ea6b954f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8403b41728b23943e14fa1b3ade0caec"><td class="memItemLeft" align="right" valign="top"><a id="a8403b41728b23943e14fa1b3ade0caec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>port</b></td></tr>
<tr class="separator:a8403b41728b23943e14fa1b3ade0caec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03470753ef2df7ad794b7f48ea82d6a3"><td class="memItemLeft" align="right" valign="top"><a id="a03470753ef2df7ad794b7f48ea82d6a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>secure</b></td></tr>
<tr class="separator:a03470753ef2df7ad794b7f48ea82d6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bc60763883f0e94bb8e092bc18086e"><td class="memItemLeft" align="right" valign="top"><a id="a35bc60763883f0e94bb8e092bc18086e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>timeout</b></td></tr>
<tr class="separator:a35bc60763883f0e94bb8e092bc18086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941b3fbf6c18bc6f21905c8e0ddc0a2f"><td class="memItemLeft" align="right" valign="top"><a id="a941b3fbf6c18bc6f21905c8e0ddc0a2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>max_size</b></td></tr>
<tr class="separator:a941b3fbf6c18bc6f21905c8e0ddc0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c158ce557491b2e18b9025b118f876"><td class="memItemLeft" align="right" valign="top"><a id="aa5c158ce557491b2e18b9025b118f876"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>max_queue</b></td></tr>
<tr class="separator:aa5c158ce557491b2e18b9025b118f876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e008f6079e0ad7cc56aca7a3b1a2923"><td class="memItemLeft" align="right" valign="top"><a id="a8e008f6079e0ad7cc56aca7a3b1a2923"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>read_limit</b></td></tr>
<tr class="separator:a8e008f6079e0ad7cc56aca7a3b1a2923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98622883794d5b772285bb1125c2e7c6"><td class="memItemLeft" align="right" valign="top"><a id="a98622883794d5b772285bb1125c2e7c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>write_limit</b></td></tr>
<tr class="separator:a98622883794d5b772285bb1125c2e7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e713204a2f0af272eff48bf31baef7b"><td class="memItemLeft" align="right" valign="top"><a id="a0e713204a2f0af272eff48bf31baef7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>loop</b></td></tr>
<tr class="separator:a0e713204a2f0af272eff48bf31baef7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81938f4507ddea187571da2df465a623"><td class="memItemLeft" align="right" valign="top"><a id="a81938f4507ddea187571da2df465a623"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>legacy_recv</b></td></tr>
<tr class="separator:a81938f4507ddea187571da2df465a623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a2261157ca65a540aa43594731c123"><td class="memItemLeft" align="right" valign="top"><a id="aa4a2261157ca65a540aa43594731c123"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>reader</b></td></tr>
<tr class="separator:aa4a2261157ca65a540aa43594731c123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae385432e282a8a95216b3d6c9da9e930"><td class="memItemLeft" align="right" valign="top"><a id="ae385432e282a8a95216b3d6c9da9e930"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>writer</b></td></tr>
<tr class="separator:ae385432e282a8a95216b3d6c9da9e930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ea7aad6918254ff547aaf5496bc903"><td class="memItemLeft" align="right" valign="top"><a id="a78ea7aad6918254ff547aaf5496bc903"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>state</b></td></tr>
<tr class="separator:a78ea7aad6918254ff547aaf5496bc903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7259881a95efa28d6578750d6ff69713"><td class="memItemLeft" align="right" valign="top"><a id="a7259881a95efa28d6578750d6ff69713"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>path</b></td></tr>
<tr class="separator:a7259881a95efa28d6578750d6ff69713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbf25d5446013825df6a30e05fdbd95"><td class="memItemLeft" align="right" valign="top"><a id="a7bbf25d5446013825df6a30e05fdbd95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>request_headers</b></td></tr>
<tr class="separator:a7bbf25d5446013825df6a30e05fdbd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0b2772e102c0dce8342181cc188e16"><td class="memItemLeft" align="right" valign="top"><a id="acd0b2772e102c0dce8342181cc188e16"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>response_headers</b></td></tr>
<tr class="separator:acd0b2772e102c0dce8342181cc188e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206e1100305ffcbe2dddb98e40a19fcc"><td class="memItemLeft" align="right" valign="top"><a id="a206e1100305ffcbe2dddb98e40a19fcc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>extensions</b></td></tr>
<tr class="separator:a206e1100305ffcbe2dddb98e40a19fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956292f04596a4b14b80eedf05e38215"><td class="memItemLeft" align="right" valign="top"><a id="a956292f04596a4b14b80eedf05e38215"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>subprotocol</b></td></tr>
<tr class="separator:a956292f04596a4b14b80eedf05e38215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d38e6973f958c8998413fe98e9c257"><td class="memItemLeft" align="right" valign="top"><a id="a52d38e6973f958c8998413fe98e9c257"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>close_code</b></td></tr>
<tr class="separator:a52d38e6973f958c8998413fe98e9c257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56e631016635155726953e23ee26186"><td class="memItemLeft" align="right" valign="top"><a id="ab56e631016635155726953e23ee26186"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>close_reason</b></td></tr>
<tr class="separator:ab56e631016635155726953e23ee26186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5092357a10a51eebafe4a58b76993e80"><td class="memItemLeft" align="right" valign="top"><a id="a5092357a10a51eebafe4a58b76993e80"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>connection_lost_waiter</b></td></tr>
<tr class="separator:a5092357a10a51eebafe4a58b76993e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1679b4019289431a4acbd896a228c8b"><td class="memItemLeft" align="right" valign="top"><a id="ae1679b4019289431a4acbd896a228c8b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>messages</b></td></tr>
<tr class="separator:ae1679b4019289431a4acbd896a228c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5cf5904debf6dc4d788172cc276156"><td class="memItemLeft" align="right" valign="top"><a id="aef5cf5904debf6dc4d788172cc276156"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>pings</b></td></tr>
<tr class="separator:aef5cf5904debf6dc4d788172cc276156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bf51e37262d617b972688951146e7e"><td class="memItemLeft" align="right" valign="top"><a id="ac5bf51e37262d617b972688951146e7e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>transfer_data_task</b></td></tr>
<tr class="separator:ac5bf51e37262d617b972688951146e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68a1d2e37b530fc0a6e4ee4bf36c087"><td class="memItemLeft" align="right" valign="top"><a id="aa68a1d2e37b530fc0a6e4ee4bf36c087"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>transfer_data_exc</b></td></tr>
<tr class="separator:aa68a1d2e37b530fc0a6e4ee4bf36c087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f2829cc92ec40822f5e975de48fb8"><td class="memItemLeft" align="right" valign="top"><a id="a227f2829cc92ec40822f5e975de48fb8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>close_connection_task</b></td></tr>
<tr class="separator:a227f2829cc92ec40822f5e975de48fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8c8c074e11b87b4ea27908c0fb8882a8"><td class="memItemLeft" align="right" valign="top"><a id="a8c8c074e11b87b4ea27908c0fb8882a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>is_client</b></td></tr>
<tr class="separator:a8c8c074e11b87b4ea27908c0fb8882a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59e1f7c159dbc58ff27b91e84467eea"><td class="memItemLeft" align="right" valign="top"><a id="af59e1f7c159dbc58ff27b91e84467eea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>side</b></td></tr>
<tr class="separator:af59e1f7c159dbc58ff27b91e84467eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This class implements common parts of the WebSocket protocol.

It assumes that the WebSocket connection is established. The handshake is
managed in subclasses such as
:class:`~websockets.server.WebSocketServerProtocol` and
:class:`~websockets.client.WebSocketClientProtocol`.

It runs a task that stores incoming data frames in a queue and deals with
control frames automatically. It sends outgoing data frames and performs
the closing handshake.

On Python ≥ 3.6, :class:`WebSocketCommonProtocol` instances support
asynchronous iteration::

    async for message in websocket:
        await process(message)

The iterator yields incoming messages. It exits normally when the
connection is closed with the status code 1000 (OK) or 1001 (going away).
It raises a :exc:`~websockets.exceptions.ConnectionClosed` exception when
the connection is closed with any other status code.

The ``host``, ``port`` and ``secure`` parameters are simply stored as
attributes for handlers that need them.

The ``timeout`` parameter defines the maximum wait time in seconds for
completing the closing handshake and, only on the client side, for
terminating the TCP connection. :meth:`close()` will complete in at most
``4 * timeout`` on the server side and ``5 * timeout`` on the client side.

The ``max_size`` parameter enforces the maximum size for incoming messages
in bytes. The default value is 1MB. ``None`` disables the limit. If a
message larger than the maximum size is received, :meth:`recv()` will
raise :exc:`~websockets.exceptions.ConnectionClosed` and the connection
will be closed with status code 1009.

The ``max_queue`` parameter sets the maximum length of the queue that holds
incoming messages. The default value is 32. 0 disables the limit. Messages
are added to an in-memory queue when they're received; then :meth:`recv()`
pops from that queue. In order to prevent excessive memory consumption when
messages are received faster than they can be processed, the queue must be
bounded. If the queue fills up, the protocol stops processing incoming data
until :meth:`recv()` is called. In this situation, various receive buffers
(at least in ``asyncio`` and in the OS) will fill up, then the TCP receive
window will shrink, slowing down transmission to avoid packet loss.

Since Python can use up to 4 bytes of memory to represent a single
character, each websocket connection may use up to ``4 * max_size *
max_queue`` bytes of memory to store incoming messages. By default,
this is 128MB. You may want to lower the limits, depending on your
application's requirements.

The ``read_limit`` argument sets the high-water limit of the buffer for
incoming bytes. The low-water limit is half the high-water limit. The
default value is 64kB, half of asyncio's default (based on the current
implementation of :class:`~asyncio.StreamReader`).

The ``write_limit`` argument sets the high-water limit of the buffer for
outgoing bytes. The low-water limit is a quarter of the high-water limit.
The default value is 64kB, equal to asyncio's default (based on the
current implementation of ``FlowControlMixin``).

As soon as the HTTP request and response in the opening handshake are
processed:

* the request path is available in the :attr:`path` attribute;
* the request and response HTTP headers are available in the
  :attr:`request_headers` and :attr:`response_headers` attributes,
  which are :class:`~websockets.http.Headers` instances.

These attributes must be treated as immutable.

If a subprotocol was negotiated, it's available in the :attr:`subprotocol`
attribute.

Once the connection is closed, the status code is available in the
:attr:`close_code` attribute and the reason in :attr:`close_reason`.</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aefe4c82f5ec19977f55679023ac608fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe4c82f5ec19977f55679023ac608fb">&#9670;&nbsp;</a></span>client_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.client_connected </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>writer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Callback when the TCP connection is established.

Record references to the stream reader and the stream writer to avoid
using private attributes ``_stream_reader`` and ``_stream_writer`` of
:class:`~asyncio.StreamReaderProtocol`.</pre> 
</div>
</div>
<a id="a0ff205f28fde8948f321c8115696fea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff205f28fde8948f321c8115696fea5">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.close </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>code</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reason</em> = <code>''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This coroutine performs the closing handshake.

It waits for the other end to complete the handshake and for the TCP
connection to terminate.

It doesn't do anything once the connection is closed. In other words
it's idemptotent.

It's safe to wrap this coroutine in :func:`~asyncio.ensure_future`
since errors during connection termination aren't particularly useful.

``code`` must be an :class:`int` and ``reason`` a :class:`str`.</pre> 
</div>
</div>
<a id="ab93f2de9e4d230c3651683245140f55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93f2de9e4d230c3651683245140f55a">&#9670;&nbsp;</a></span>close_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.close_connection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">7.1.1. Close the WebSocket Connection

When the opening handshake succeeds, :meth:`connection_open` starts
this coroutine in a task. It waits for the data transfer phase to
complete then it closes the TCP connection cleanly.

When the opening handshake fails, :meth:`fail_connection` does the
same. There's no data transfer phase in that case.</pre> 
</div>
</div>
<a id="a52bc1f93413a8480ae83af00848d89f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bc1f93413a8480ae83af00848d89f6">&#9670;&nbsp;</a></span>closed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.closed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This property is ``True`` once the connection is closed.

Be aware that both :attr:`open` and :attr`closed` are ``False`` during
the opening and closing sequences.</pre> 
</div>
</div>
<a id="a726b03e5dfb763929cd619a768b7acd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726b03e5dfb763929cd619a768b7acd0">&#9670;&nbsp;</a></span>connection_lost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.connection_lost </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">7.1.4. The WebSocket Connection is Closed.</pre> 
</div>
</div>
<a id="a8b650d7fe663c9465e7fc027689cad4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b650d7fe663c9465e7fc027689cad4e">&#9670;&nbsp;</a></span>connection_made()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.connection_made </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Configure write buffer limits.

The high-water limit is defined by ``self.write_limit``.

The low-water limit currently defaults to ``self.write_limit // 4`` in
:meth:`~asyncio.WriteTransport.set_write_buffer_limits`, which should
be all right for reasonable use cases of this library.

This is the earliest point where we can get hold of the transport,
which means it's the best point for configuring it.</pre> 
</div>
</div>
<a id="aae85117dc05aa48fa6de503bab27fef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae85117dc05aa48fa6de503bab27fef5">&#9670;&nbsp;</a></span>connection_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.connection_open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Callback when the WebSocket opening handshake completes.

Enter the OPEN state and start the data transfer phase.</pre> 
</div>
</div>
<a id="a35bfc837fed80493c2196001363cc1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bfc837fed80493c2196001363cc1d4">&#9670;&nbsp;</a></span>ensure_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.ensure_open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check that the WebSocket connection is open.

Raise :exc:`~websockets.exceptions.ConnectionClosed` if it isn't.</pre> 
</div>
</div>
<a id="a10b5889a53c9bbb91fe209627c321297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b5889a53c9bbb91fe209627c321297">&#9670;&nbsp;</a></span>eof_received()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.eof_received </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Close the transport after receiving EOF.

Since Python 3.5, `:meth:~StreamReaderProtocol.eof_received` returns
``True`` on non-TLS connections.

See http://bugs.python.org/issue24539 for more information.

This is inappropriate for websockets for at least three reasons:

1. The use case is to read data until EOF with self.reader.read(-1).
   Since websockets is a TLV protocol, this never happens.

2. It doesn't work on TLS connections. A falsy value must be
   returned to have the same behavior on TLS and plain connections.

3. The websockets protocol has its own closing handshake. Endpoints
   close the TCP connection after sending a close frame.

As a consequence we revert to the previous, more useful behavior.</pre> 
</div>
</div>
<a id="a618b79d4fa0be44b89561f8abab709e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618b79d4fa0be44b89561f8abab709e1">&#9670;&nbsp;</a></span>fail_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.fail_connection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>code</em> = <code>1006</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reason</em> = <code>''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">7.1.7. Fail the WebSocket Connection

This requires:

1. Stopping all processing of incoming data, which means cancelling
   :attr:`transfer_data_task`. The close code will be 1006 unless a
   close frame was received earlier.

2. Sending a close frame with an appropriate code if the opening
   handshake succeeded and the other side is likely to process it.

3. Closing the connection. :meth:`close_connection` takes care of
   this once :attr:`transfer_data_task` exits after being cancelled.

(The specification describes these steps in the opposite order.)

Return a :class:`~asyncio.Task` that completes when the TCP connection
is closed.</pre> 
</div>
</div>
<a id="a147f81a594cc1d7f952a90800283ff2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147f81a594cc1d7f952a90800283ff2d">&#9670;&nbsp;</a></span>local_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.local_address </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Local address of the connection.

This is a ``(host, port)`` tuple or ``None`` if the connection hasn't
been established yet.</pre> 
</div>
</div>
<a id="ac646626706d4fea1e2ac92c056d1b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac646626706d4fea1e2ac92c056d1b572">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.open </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This property is ``True`` when the connection is usable.

It may be used to detect disconnections but this is discouraged per
the EAFP_ principle. When ``open`` is ``False``, using the connection
raises a :exc:`~websockets.exceptions.ConnectionClosed` exception.

.. _EAFP: https://docs.python.org/3/glossary.html#term-eafp</pre> 
</div>
</div>
<a id="a660f3e46bbe578a1c624c544bf3e9e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660f3e46bbe578a1c624c544bf3e9e87">&#9670;&nbsp;</a></span>ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.ping </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This coroutine sends a ping.

It returns a :class:`~asyncio.Future` which will be completed when the
corresponding pong is received and which you may ignore if you don't
want to wait.

A ping may serve as a keepalive or as a check that the remote endpoint
received all messages up to this point::

    pong_waiter = await ws.ping()
    await pong_waiter   # only if you want to wait for the pong

By default, the ping contains four random bytes. The content may be
overridden with the optional ``data`` argument which must be of type
:class:`str` (which will be encoded to UTF-8) or :class:`bytes`.</pre> 
</div>
</div>
<a id="aaac0bd94a1cf0015cb0aa687daf78676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac0bd94a1cf0015cb0aa687daf78676">&#9670;&nbsp;</a></span>pong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.pong </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em> = <code>b''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This coroutine sends a pong.

An unsolicited pong may serve as a unidirectional heartbeat.

The content may be overridden with the optional ``data`` argument
which must be of type :class:`str` (which will be encoded to UTF-8) or
:class:`bytes`.</pre> 
</div>
</div>
<a id="a0736093eb665ea46a97730d255173cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0736093eb665ea46a97730d255173cb9">&#9670;&nbsp;</a></span>read_data_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.read_data_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a single data frame from the connection.

Process control frames received before the next data frame.

Return ``None`` if a close frame is encountered before any data frame.</pre> 
</div>
</div>
<a id="a8d8d236293e7897c4574b63f25d65fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8d236293e7897c4574b63f25d65fae">&#9670;&nbsp;</a></span>read_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.read_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a single frame from the connection.</pre> 
</div>
</div>
<a id="a4de6a491a4d3bb17bdd6ede36c3ad114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de6a491a4d3bb17bdd6ede36c3ad114">&#9670;&nbsp;</a></span>read_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.read_message </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a single message from the connection.

Re-assemble data frames if the message is fragmented.

Return ``None`` when the closing handshake is started.</pre> 
</div>
</div>
<a id="a98319d5e461fef80290790f0bfbb51f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98319d5e461fef80290790f0bfbb51f2">&#9670;&nbsp;</a></span>recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.recv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This coroutine receives the next message.

It returns a :class:`str` for a text frame and :class:`bytes` for a
binary frame.

When the end of the message stream is reached, :meth:`recv` raises
:exc:`~websockets.exceptions.ConnectionClosed`. This can happen after
a normal connection closure, a protocol error or a network failure.

.. versionchanged:: 3.0

    :meth:`recv` used to return ``None`` instead. Refer to the
    changelog for details.</pre> 
</div>
</div>
<a id="a9eb8d78c5c3d633d9636ffd773de87ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb8d78c5c3d633d9636ffd773de87ae">&#9670;&nbsp;</a></span>remote_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.remote_address </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remote address of the connection.

This is a ``(host, port)`` tuple or ``None`` if the connection hasn't
been established yet.</pre> 
</div>
</div>
<a id="a18d893d014ed4d263ac98d1bf6034caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d893d014ed4d263ac98d1bf6034caf">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.send </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This coroutine sends a message.

It sends :class:`str` as a text frame and :class:`bytes` as a binary
frame. It raises a :exc:`TypeError` for other inputs.</pre> 
</div>
</div>
<a id="a07a6c3c50dd1f87096a3f191780d9c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a6c3c50dd1f87096a3f191780d9c2c">&#9670;&nbsp;</a></span>transfer_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.transfer_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read incoming messages and put them in a queue.

This coroutine runs in a task until the closing handshake is started.</pre> 
</div>
</div>
<a id="a0da1c941470085c421ae779bbfef40bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da1c941470085c421ae779bbfef40bb">&#9670;&nbsp;</a></span>wait_for_connection_lost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.wait_for_connection_lost </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wait until the TCP connection is closed or ``self.timeout`` elapses.

Return ``True`` if the connection is closed and ``False`` otherwise.</pre> 
</div>
</div>
<a id="a1634532917578e526a294c1c94c81914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1634532917578e526a294c1c94c81914">&#9670;&nbsp;</a></span>write_close_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.write_close_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em> = <code>b''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write a close frame if and only if the connection state is OPEN.

This dedicated coroutine must be used for writing close frames to
ensure that at most one close frame is sent on a given connection.</pre> 
</div>
</div>
<a id="abc8c8138e1b8a415fdfd3996cb1e7196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8c8138e1b8a415fdfd3996cb1e7196">&#9670;&nbsp;</a></span>writer_is_closing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def websockets.protocol.WebSocketCommonProtocol.writer_is_closing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Backport of https://github.com/python/asyncio/pull/291.

Replace with ``self.writer.transport.is_closing()`` when dropping
support for Python &lt; 3.6 and with ``self.writer.is_closing()`` when
https://bugs.python.org/issue31491 is fixed.</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>venv/lib/python3.6/site-packages/websockets/protocol.py</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>websockets</b></li><li class="navelem"><a class="el" href="namespacewebsockets_1_1protocol.html">protocol</a></li><li class="navelem"><a class="el" href="classwebsockets_1_1protocol_1_1_web_socket_common_protocol.html">WebSocketCommonProtocol</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
